{"ast":null,"code":"import parsePhoneNumber_, { getCountryCallingCode, AsYouType, Metadata } from 'libphonenumber-js/core';\nimport getInternationalPhoneNumberPrefix from './getInternationalPhoneNumberPrefix';\n/**\n * Decides which country should be pre-selected\n * when the phone number input component is first mounted.\n * @param  {object?} phoneNumber - An instance of `PhoneNumber` class.\n * @param  {string?} country - Pre-defined country (two-letter code).\n * @param  {string[]?} countries - A list of countries available.\n * @param  {object} metadata - `libphonenumber-js` metadata\n * @return {string?}\n */\n\nexport function getPreSelectedCountry(_ref) {\n  var value = _ref.value,\n    phoneNumber = _ref.phoneNumber,\n    defaultCountry = _ref.defaultCountry,\n    getAnyCountry = _ref.getAnyCountry,\n    countries = _ref.countries,\n    required = _ref.required,\n    metadata = _ref.metadata;\n  var country; // If can get country from E.164 phone number\n  // then it overrides the `country` passed (or not passed).\n\n  if (phoneNumber && phoneNumber.country) {\n    // `country` will be left `undefined` in case of non-detection.\n    country = phoneNumber.country;\n  } else if (defaultCountry) {\n    if (!value || couldNumberBelongToCountry(value, defaultCountry, metadata)) {\n      country = defaultCountry;\n    }\n  } // Only pre-select a country if it's in the available `countries` list.\n\n  if (countries && countries.indexOf(country) < 0) {\n    country = undefined;\n  } // If there will be no \"International\" option\n  // then some `country` must be selected.\n  // It will still be the wrong country though.\n  // But still country `<select/>` can't be left in a broken state.\n\n  if (!country && required && countries && countries.length > 0) {\n    country = getAnyCountry(); // noCountryMatchesTheNumber = true\n  }\n  return country;\n}\n/**\n * Generates a sorted list of country `<select/>` options.\n * @param  {string[]} countries - A list of two-letter (\"ISO 3166-1 alpha-2\") country codes.\n * @param  {object} labels - Custom country labels. E.g. `{ RU: 'Россия', US: 'США', ... }`.\n * @param  {boolean} addInternationalOption - Whether should include \"International\" option at the top of the list.\n * @return {object[]} A list of objects having shape `{ value : string, label : string }`.\n */\n\nexport function getCountrySelectOptions(_ref2) {\n  var countries = _ref2.countries,\n    countryNames = _ref2.countryNames,\n    addInternationalOption = _ref2.addInternationalOption,\n    compareStringsLocales = _ref2.compareStringsLocales,\n    _compareStrings = _ref2.compareStrings;\n\n  // Default country name comparator uses `String.localeCompare()`.\n  if (!_compareStrings) {\n    _compareStrings = compareStrings;\n  } // Generates a `<Select/>` option for each country.\n\n  var countrySelectOptions = countries.map(function (country) {\n    return {\n      value: country,\n      // All `locale` country names included in this library\n      // include all countries (this is checked at build time).\n      // The only case when a country name might be missing\n      // is when a developer supplies their own `labels` property.\n      // To guard against such cases, a missing country name\n      // is substituted by country code.\n      label: countryNames[country] || country\n    };\n  }); // Sort the list of countries alphabetically.\n\n  countrySelectOptions.sort(function (a, b) {\n    return _compareStrings(a.label, b.label, compareStringsLocales);\n  }); // Add the \"International\" option to the country list (if suitable)\n\n  if (addInternationalOption) {\n    countrySelectOptions.unshift({\n      label: countryNames.ZZ\n    });\n  }\n  return countrySelectOptions;\n}\n/**\n * Parses a E.164 phone number to an instance of `PhoneNumber` class.\n * @param {string?} value = E.164 phone number.\n * @param  {object} metadata - `libphonenumber-js` metadata\n * @return {object} Object having shape `{ country: string?, countryCallingCode: string, number: string }`. `PhoneNumber`: https://gitlab.com/catamphetamine/libphonenumber-js#phonenumber.\n * @example\n * parsePhoneNumber('+78005553535')\n */\n\nexport function parsePhoneNumber(value, metadata) {\n  return parsePhoneNumber_(value || '', metadata);\n}\n/**\n * Generates national number digits for a parsed phone.\n * May prepend national prefix.\n * The phone number must be a complete and valid phone number.\n * @param  {object} phoneNumber - An instance of `PhoneNumber` class.\n * @param  {object} metadata - `libphonenumber-js` metadata\n * @return {string}\n * @example\n * getNationalNumberDigits({ country: 'RU', phone: '8005553535' })\n * // returns '88005553535'\n */\n\nexport function generateNationalNumberDigits(phoneNumber) {\n  return phoneNumber.formatNational().replace(/\\D/g, '');\n}\n/**\n * Migrates parsed `<input/>` `value` for the newly selected `country`.\n * @param {string?} phoneDigits - Phone number digits (and `+`) parsed from phone number `<input/>` (it's not the same as the `value` property).\n * @param {string?} prevCountry - Previously selected country.\n * @param {string?} newCountry - Newly selected country. Can't be same as previously selected country.\n * @param {object} metadata - `libphonenumber-js` metadata.\n * @param {boolean} useNationalFormat - whether should attempt to convert from international to national number for the new country.\n * @return {string?}\n */\n\nexport function getPhoneDigitsForNewCountry(phoneDigits, _ref3) {\n  var prevCountry = _ref3.prevCountry,\n    newCountry = _ref3.newCountry,\n    metadata = _ref3.metadata,\n    useNationalFormat = _ref3.useNationalFormat;\n  if (prevCountry === newCountry) {\n    return phoneDigits;\n  } // If `parsed_input` is empty\n  // then no need to migrate anything.\n\n  if (!phoneDigits) {\n    if (useNationalFormat) {\n      return '';\n    } else {\n      // If `phoneDigits` is empty then set `phoneDigits` to\n      // `+{getCountryCallingCode(newCountry)}`.\n      return getInternationalPhoneNumberPrefix(newCountry, metadata);\n    }\n  } // If switching to some country.\n  // (from \"International\" or another country)\n  // If switching from \"International\" then `phoneDigits` starts with a `+`.\n  // Otherwise it may or may not start with a `+`.\n\n  if (newCountry) {\n    // If the phone number was entered in international format\n    // then migrate it to the newly selected country.\n    // The phone number may be incomplete.\n    // The phone number entered not necessarily starts with\n    // the previously selected country phone prefix.\n    if (phoneDigits[0] === '+') {\n      // If the international phone number is for the new country\n      // then convert it to local if required.\n      if (useNationalFormat) {\n        // // If a phone number is being input in international form\n        // // and the country can already be derived from it,\n        // // and if it is the new country, then format as a national number.\n        // const derived_country = getCountryFromPossiblyIncompleteInternationalPhoneNumber(phoneDigits, metadata)\n        // if (derived_country === newCountry) {\n        // \treturn stripCountryCallingCode(phoneDigits, derived_country, metadata)\n        // }\n        // Actually, the two countries don't necessarily need to match:\n        // the condition could be looser here, because several countries\n        // might share the same international phone number format\n        // (for example, \"NANPA\" countries like US, Canada, etc).\n        // The looser condition would be just \"same nternational phone number format\"\n        // which would mean \"same country calling code\" in the context of `libphonenumber-js`.\n        if (phoneDigits.indexOf('+' + getCountryCallingCode(newCountry, metadata)) === 0) {\n          return stripCountryCallingCode(phoneDigits, newCountry, metadata);\n        } // Simply discard the previously entered international phone number,\n        // because otherwise any \"smart\" transformation like getting the\n        // \"national (significant) number\" part and then prepending the\n        // newly selected country's \"country calling code\" to it\n        // would just be confusing for a user without being actually useful.\n\n        return ''; // // Simply strip the leading `+` character\n        // // therefore simply converting all digits into a \"local\" phone number.\n        // // https://github.com/catamphetamine/react-phone-number-input/issues/287\n        // return phoneDigits.slice(1)\n      }\n      if (prevCountry) {\n        var newCountryPrefix = getInternationalPhoneNumberPrefix(newCountry, metadata);\n        if (phoneDigits.indexOf(newCountryPrefix) === 0) {\n          return phoneDigits;\n        } else {\n          return newCountryPrefix;\n        }\n      } else {\n        var defaultValue = getInternationalPhoneNumberPrefix(newCountry, metadata); // If `phoneDigits`'s country calling code part is the same\n        // as for the new `country`, then leave `phoneDigits` as is.\n\n        if (phoneDigits.indexOf(defaultValue) === 0) {\n          return phoneDigits;\n        } // If `phoneDigits`'s country calling code part is not the same\n        // as for the new `country`, then set `phoneDigits` to\n        // `+{getCountryCallingCode(newCountry)}`.\n\n        return defaultValue;\n      } // // If the international phone number already contains\n      // // any country calling code then trim the country calling code part.\n      // // (that could also be the newly selected country phone code prefix as well)\n      // // `phoneDigits` doesn't neccessarily belong to `prevCountry`.\n      // // (e.g. if a user enters an international number\n      // //  not belonging to any of the reduced `countries` list).\n      // phoneDigits = stripCountryCallingCode(phoneDigits, prevCountry, metadata)\n      // // Prepend country calling code prefix\n      // // for the newly selected country.\n      // return e164(phoneDigits, newCountry, metadata) || `+${getCountryCallingCode(newCountry, metadata)}`\n    }\n  } // If switching to \"International\" from a country.\n  else {\n    // If the phone number was entered in national format.\n    if (phoneDigits[0] !== '+') {\n      // Format the national phone number as an international one.\n      // The phone number entered not necessarily even starts with\n      // the previously selected country phone prefix.\n      // Even if the phone number belongs to whole another country\n      // it will still be parsed into some national phone number.\n      //\n      // Ignore the now-uncovered `|| ''` code branch:\n      // previously `e164()` function could return an empty string\n      // even when `phoneDigits` were not empty.\n      // Now it always returns some `value` when there're any `phoneDigits`.\n      // Still, didn't remove the `|| ''` code branch just in case\n      // that logic changes somehow in some future, so there're no\n      // possible bugs related to that.\n      //\n      // (ignore the `|| ''` code branch)\n\n      /* istanbul ignore next */\n      return e164(phoneDigits, prevCountry, metadata) || '';\n    }\n  }\n  return phoneDigits;\n}\n/**\n * Converts phone number digits to a (possibly incomplete) E.164 phone number.\n * @param  {string?} number - A possibly incomplete phone number digits string. Can be a possibly incomplete E.164 phone number.\n * @param  {string?} country\n * @param  {object} metadata - `libphonenumber-js` metadata.\n * @return {string?}\n */\n\nexport function e164(number, country, metadata) {\n  if (!number) {\n    return;\n  } // If the phone number is being input in international format.\n\n  if (number[0] === '+') {\n    // If it's just the `+` sign then return nothing.\n    if (number === '+') {\n      return;\n    } // Return a E.164 phone number.\n    //\n    // Could return `number` \"as is\" here, but there's a possibility\n    // that some user might incorrectly input an international number\n    // with a \"national prefix\". Such numbers aren't considered valid,\n    // but `libphonenumber-js` is \"forgiving\" when it comes to parsing\n    // user's input, and this input component follows that behavior.\n    //\n\n    var asYouType = new AsYouType(country, metadata);\n    asYouType.input(number); // This function would return `undefined` only when `number` is `\"+\"`,\n    // but at this point it is known that `number` is not `\"+\"`.\n\n    return asYouType.getNumberValue();\n  } // For non-international phone numbers\n  // an accompanying country code is required.\n  // The situation when `country` is `undefined`\n  // and a non-international phone number is passed\n  // to this function shouldn't happen.\n\n  if (!country) {\n    return;\n  }\n  var partial_national_significant_number = getNationalSignificantNumberDigits(number, country, metadata); //\n  // Even if no \"national (significant) number\" digits have been input,\n  // still return a non-`undefined` value.\n  // https://gitlab.com/catamphetamine/react-phone-number-input/-/issues/113\n  //\n  // For example, if the user has selected country `US` and entered `\"1\"`\n  // then that `\"1\"` is just a \"national prefix\" and no \"national (significant) number\"\n  // digits have been input yet. Still, return `\"+1\"` as `value` in such cases,\n  // because otherwise the app would think that the input is empty and mark it as such\n  // while in reality it isn't empty, which might be thought of as a \"bug\", or just\n  // a \"weird\" behavior.\n  //\n  // if (partial_national_significant_number) {\n\n  return \"+\".concat(getCountryCallingCode(country, metadata)).concat(partial_national_significant_number || ''); // }\n}\n/**\n * Trims phone number digits if they exceed the maximum possible length\n * for a national (significant) number for the country.\n * @param  {string} number - A possibly incomplete phone number digits string. Can be a possibly incomplete E.164 phone number.\n * @param  {string} country\n * @param  {object} metadata - `libphonenumber-js` metadata.\n * @return {string} Can be empty.\n */\n\nexport function trimNumber(number, country, metadata) {\n  var nationalSignificantNumberPart = getNationalSignificantNumberDigits(number, country, metadata);\n  if (nationalSignificantNumberPart) {\n    var overflowDigitsCount = nationalSignificantNumberPart.length - getMaxNumberLength(country, metadata);\n    if (overflowDigitsCount > 0) {\n      return number.slice(0, number.length - overflowDigitsCount);\n    }\n  }\n  return number;\n}\nfunction getMaxNumberLength(country, metadata) {\n  // Get \"possible lengths\" for a phone number of the country.\n  metadata = new Metadata(metadata);\n  metadata.selectNumberingPlan(country); // Return the last \"possible length\".\n\n  return metadata.numberingPlan.possibleLengths()[metadata.numberingPlan.possibleLengths().length - 1];\n} // If the phone number being input is an international one\n// then tries to derive the country from the phone number.\n// (regardless of whether there's any country currently selected)\n\n/**\n * @param {string} partialE164Number - A possibly incomplete E.164 phone number.\n * @param {string?} country - Currently selected country.\n * @param {string[]?} countries - A list of available countries. If not passed then \"all countries\" are assumed.\n * @param  {object} metadata - `libphonenumber-js` metadata.\n * @return {string?}\n */\n\nexport function getCountryForPartialE164Number(partialE164Number, _ref4) {\n  var country = _ref4.country,\n    countries = _ref4.countries,\n    required = _ref4.required,\n    metadata = _ref4.metadata;\n  if (partialE164Number === '+') {\n    // Don't change the currently selected country yet.\n    return country;\n  }\n  var derived_country = getCountryFromPossiblyIncompleteInternationalPhoneNumber(partialE164Number, metadata); // If a phone number is being input in international form\n  // and the country can already be derived from it,\n  // then select that country.\n\n  if (derived_country && (!countries || countries.indexOf(derived_country) >= 0)) {\n    return derived_country;\n  } // If \"International\" country option has not been disabled\n  // and the international phone number entered doesn't correspond\n  // to the currently selected country then reset the currently selected country.\n  else if (country && !required && !couldNumberBelongToCountry(partialE164Number, country, metadata)) {\n    return undefined;\n  } // Don't change the currently selected country.\n\n  return country;\n}\n/**\n * Parses `<input/>` value. Derives `country` from `input`. Derives an E.164 `value`.\n * @param  {string?} phoneDigits — Parsed `<input/>` value. Examples: `\"\"`, `\"+\"`, `\"+123\"`, `\"123\"`.\n * @param  {string?} prevPhoneDigits — Previous parsed `<input/>` value. Examples: `\"\"`, `\"+\"`, `\"+123\"`, `\"123\"`.\n * @param  {string?} country - Currently selected country.\n * @param  {boolean} countryRequired - Is selecting some country required.\n * @param  {function} getAnyCountry - Can be used to get any country when selecting some country required.\n * @param  {string[]?} countries - A list of available countries. If not passed then \"all countries\" are assumed.\n * @param  {boolean} international - Set to `true` to force international phone number format (leading `+`). Set to `false` to force \"national\" phone number format. Is `undefined` by default.\n * @param  {boolean} limitMaxLength — Whether to enable limiting phone number max length.\n * @param  {object} metadata - `libphonenumber-js` metadata.\n * @return {object} An object of shape `{ input, country, value }`.\n */\n\nexport function onPhoneDigitsChange(phoneDigits, _ref5) {\n  var prevPhoneDigits = _ref5.prevPhoneDigits,\n    country = _ref5.country,\n    defaultCountry = _ref5.defaultCountry,\n    countryRequired = _ref5.countryRequired,\n    getAnyCountry = _ref5.getAnyCountry,\n    countries = _ref5.countries,\n    international = _ref5.international,\n    limitMaxLength = _ref5.limitMaxLength,\n    countryCallingCodeEditable = _ref5.countryCallingCodeEditable,\n    metadata = _ref5.metadata;\n  if (international && countryCallingCodeEditable === false) {\n    var prefix = getInternationalPhoneNumberPrefix(country, metadata); // The `<input/>` value must start with the country calling code.\n\n    if (phoneDigits.indexOf(prefix) !== 0) {\n      var _value; // If a phone number input is declared as\n      // `international` and `withCountryCallingCode`,\n      // then it's gonna be non-empty even before the user\n      // has input anything in it.\n      // This will result in its contents (the country calling code part)\n      // being selected when the user tabs into such field.\n      // If the user then starts inputting the national part digits,\n      // then `<input/>` value changes from `+xxx` to `y`\n      // because inputting anything while having the `<input/>` value\n      // selected results in erasing the `<input/>` value.\n      // So, the component handles such case by restoring\n      // the intended `<input/>` value: `+xxxy`.\n      // https://gitlab.com/catamphetamine/react-phone-number-input/-/issues/43\n\n      if (phoneDigits && phoneDigits[0] !== '+') {\n        phoneDigits = prefix + phoneDigits;\n        _value = e164(phoneDigits, country, metadata);\n      } else {\n        phoneDigits = prefix;\n      }\n      return {\n        phoneDigits: phoneDigits,\n        value: _value,\n        country: country\n      };\n    }\n  } // If `international` property is `false`, then it means\n  // \"enforce national-only format during input\",\n  // so, if that's the case, then remove all `+` characters,\n  // but only if some country is currently selected.\n  // (not if \"International\" country is selected).\n\n  if (international === false && country && phoneDigits && phoneDigits[0] === '+') {\n    phoneDigits = convertInternationalPhoneDigitsToNational(phoneDigits, country, metadata);\n  } // Trim the input to not exceed the maximum possible number length.\n\n  if (phoneDigits && country && limitMaxLength) {\n    phoneDigits = trimNumber(phoneDigits, country, metadata);\n  } // If this `onChange()` event was triggered\n  // as a result of selecting \"International\" country,\n  // then force-prepend a `+` sign if the phone number\n  // `<input/>` value isn't in international format.\n  // Also, force-prepend a `+` sign if international\n  // phone number input format is set.\n\n  if (phoneDigits && phoneDigits[0] !== '+' && (!country || international)) {\n    phoneDigits = '+' + phoneDigits;\n  } // If the previously entered phone number\n  // has been entered in international format\n  // and the user decides to erase it,\n  // then also reset the `country`\n  // because it was most likely automatically selected\n  // while the user was typing in the phone number\n  // in international format.\n  // This fixes the issue when a user is presented\n  // with a phone number input with no country selected\n  // and then types in their local phone number\n  // then discovers that the input's messed up\n  // (a `+` has been prepended at the start of their input\n  //  and a random country has been selected),\n  // decides to undo it all by erasing everything\n  // and then types in their local phone number again\n  // resulting in a seemingly correct phone number\n  // but in reality that phone number has incorrect country.\n  // https://github.com/catamphetamine/react-phone-number-input/issues/273\n\n  if (!phoneDigits && prevPhoneDigits && prevPhoneDigits[0] === '+') {\n    if (international) {\n      country = undefined;\n    } else {\n      country = defaultCountry;\n    }\n  } // Also resets such \"randomly\" selected country\n  // as soon as the user erases the number\n  // digit-by-digit up to the leading `+` sign.\n\n  if (phoneDigits === '+' && prevPhoneDigits && prevPhoneDigits[0] === '+' && prevPhoneDigits.length > '+'.length) {\n    country = undefined;\n  } // Generate the new `value` property.\n\n  var value;\n  if (phoneDigits) {\n    if (phoneDigits[0] === '+') {\n      if (phoneDigits === '+') {\n        value = undefined;\n      } else if (country && getInternationalPhoneNumberPrefix(country, metadata).indexOf(phoneDigits) === 0) {\n        // Selected a `country` but started inputting an\n        // international phone number for another country.\n        // Even though the input value is non-empty,\n        // the `value` is assumed `undefined` in such case.\n        // The `country` will be reset (or re-selected)\n        // immediately after such mismatch has been detected\n        // by the phone number input component, and `value`\n        // will be set to the currently entered international prefix.\n        //\n        // For example, if selected `country` `\"US\"`\n        // and started inputting phone number `\"+2\"`\n        // then `value` `undefined` will be returned from this function,\n        // and then, immediately after that, `country` will be reset\n        // and the `value` will be set to `\"+2\"`.\n        //\n        value = undefined;\n      } else {\n        value = e164(phoneDigits, country, metadata);\n      }\n    } else {\n      value = e164(phoneDigits, country, metadata);\n    }\n  } // Derive the country from the phone number.\n  // (regardless of whether there's any country currently selected,\n  //  because there could be several countries corresponding to one country calling code)\n\n  if (value) {\n    country = getCountryForPartialE164Number(value, {\n      country: country,\n      countries: countries,\n      metadata: metadata\n    }); // If `international` property is `false`, then it means\n    // \"enforce national-only format during input\",\n    // so, if that's the case, then remove all `+` characters,\n    // but only if some country is currently selected.\n    // (not if \"International\" country is selected).\n\n    if (international === false && country && phoneDigits && phoneDigits[0] === '+') {\n      phoneDigits = convertInternationalPhoneDigitsToNational(phoneDigits, country, metadata); // Re-calculate `value` because `phoneDigits` has changed.\n\n      value = e164(phoneDigits, country, metadata);\n    }\n  }\n  if (!country && countryRequired) {\n    country = defaultCountry || getAnyCountry();\n  }\n  return {\n    phoneDigits: phoneDigits,\n    country: country,\n    value: value\n  };\n}\nfunction convertInternationalPhoneDigitsToNational(input, country, metadata) {\n  // Handle the case when a user might have pasted\n  // a phone number in international format.\n  if (input.indexOf(getInternationalPhoneNumberPrefix(country, metadata)) === 0) {\n    // Create \"as you type\" formatter.\n    var formatter = new AsYouType(country, metadata); // Input partial national phone number.\n\n    formatter.input(input); // Return the parsed partial national phone number.\n\n    var phoneNumber = formatter.getNumber();\n    if (phoneNumber) {\n      // Transform the number to a national one,\n      // and remove all non-digits.\n      return phoneNumber.formatNational().replace(/\\D/g, '');\n    } else {\n      return '';\n    }\n  } else {\n    // Just remove the `+` sign.\n    return input.replace(/\\D/g, '');\n  }\n}\n/**\n * Determines the country for a given (possibly incomplete) E.164 phone number.\n * @param  {string} number - A possibly incomplete E.164 phone number.\n * @param  {object} metadata - `libphonenumber-js` metadata.\n * @return {string?}\n */\n\nexport function getCountryFromPossiblyIncompleteInternationalPhoneNumber(number, metadata) {\n  var formatter = new AsYouType(null, metadata);\n  formatter.input(number); // // `001` is a special \"non-geograpical entity\" code\n  // // in Google's `libphonenumber` library.\n  // if (formatter.getCountry() === '001') {\n  // \treturn\n  // }\n\n  return formatter.getCountry();\n}\n/**\n * Compares two strings.\n * A helper for `Array.sort()`.\n * @param {string} a — First string.\n * @param {string} b — Second string.\n * @param {(string[]|string)} [locales] — The `locales` argument of `String.localeCompare`.\n */\n\nexport function compareStrings(a, b, locales) {\n  // Use `String.localeCompare` if it's available.\n  // https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare\n  // Which means everyone except IE <= 10 and Safari <= 10.\n  // `localeCompare()` is available in latest Node.js versions.\n\n  /* istanbul ignore else */\n  if (String.prototype.localeCompare) {\n    return a.localeCompare(b, locales);\n  }\n  /* istanbul ignore next */\n\n  return a < b ? -1 : a > b ? 1 : 0;\n}\n/**\n * Strips `+${countryCallingCode}` prefix from an E.164 phone number.\n * @param {string} number - (possibly incomplete) E.164 phone number.\n * @param {string?} country - A possible country for this phone number.\n * @param {object} metadata - `libphonenumber-js` metadata.\n * @return {string}\n */\n\nexport function stripCountryCallingCode(number, country, metadata) {\n  // Just an optimization, so that it\n  // doesn't have to iterate through all country calling codes.\n  if (country) {\n    var countryCallingCodePrefix = '+' + getCountryCallingCode(country, metadata); // If `country` fits the actual `number`.\n\n    if (number.length < countryCallingCodePrefix.length) {\n      if (countryCallingCodePrefix.indexOf(number) === 0) {\n        return '';\n      }\n    } else {\n      if (number.indexOf(countryCallingCodePrefix) === 0) {\n        return number.slice(countryCallingCodePrefix.length);\n      }\n    }\n  } // If `country` doesn't fit the actual `number`.\n  // Try all available country calling codes.\n\n  for (var _i = 0, _Object$keys = Object.keys(metadata.country_calling_codes); _i < _Object$keys.length; _i++) {\n    var country_calling_code = _Object$keys[_i];\n    if (number.indexOf(country_calling_code) === '+'.length) {\n      return number.slice('+'.length + country_calling_code.length);\n    }\n  }\n  return '';\n}\n/**\n * Parses a partially entered national phone number digits\n * (or a partially entered E.164 international phone number)\n * and returns the national significant number part.\n * National significant number returned doesn't come with a national prefix.\n * @param {string} number - National number digits. Or possibly incomplete E.164 phone number.\n * @param {string?} country\n * @param {object} metadata - `libphonenumber-js` metadata.\n * @return {string} [result]\n */\n\nexport function getNationalSignificantNumberDigits(number, country, metadata) {\n  // Create \"as you type\" formatter.\n  var formatter = new AsYouType(country, metadata); // Input partial national phone number.\n\n  formatter.input(number); // Return the parsed partial national phone number.\n\n  var phoneNumber = formatter.getNumber();\n  return phoneNumber && phoneNumber.nationalNumber;\n}\n/**\n * Checks if a partially entered E.164 phone number could belong to a country.\n * @param  {string} number\n * @param  {string} country\n * @return {boolean}\n */\n\nexport function couldNumberBelongToCountry(number, country, metadata) {\n  var intlPhoneNumberPrefix = getInternationalPhoneNumberPrefix(country, metadata);\n  var i = 0;\n  while (i < number.length && i < intlPhoneNumberPrefix.length) {\n    if (number[i] !== intlPhoneNumberPrefix[i]) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n}\n/**\n * Gets initial \"phone digits\" (including `+`, if using international format).\n * @return {string} [phoneDigits] Returns `undefined` if there should be no initial \"phone digits\".\n */\n\nexport function getInitialPhoneDigits(_ref6) {\n  var value = _ref6.value,\n    phoneNumber = _ref6.phoneNumber,\n    defaultCountry = _ref6.defaultCountry,\n    international = _ref6.international,\n    useNationalFormat = _ref6.useNationalFormat,\n    metadata = _ref6.metadata;\n\n  // If the `value` (E.164 phone number)\n  // belongs to the currently selected country\n  // and `useNationalFormat` is `true`\n  // then convert `value` (E.164 phone number)\n  // to a local phone number digits.\n  // E.g. '+78005553535' -> '88005553535'.\n  if ((international === false || useNationalFormat) && phoneNumber && phoneNumber.country) {\n    return generateNationalNumberDigits(phoneNumber);\n  } // If `international` property is `true`,\n  // meaning \"enforce international phone number format\",\n  // then always show country calling code in the input field.\n\n  if (!value && international && defaultCountry) {\n    return getInternationalPhoneNumberPrefix(defaultCountry, metadata);\n  }\n  return value;\n}","map":{"version":3,"names":["parsePhoneNumber_","getCountryCallingCode","AsYouType","Metadata","getInternationalPhoneNumberPrefix","getPreSelectedCountry","_ref","value","phoneNumber","defaultCountry","getAnyCountry","countries","required","metadata","country","couldNumberBelongToCountry","indexOf","undefined","length","getCountrySelectOptions","_ref2","countryNames","addInternationalOption","compareStringsLocales","_compareStrings","compareStrings","countrySelectOptions","map","label","sort","a","b","unshift","ZZ","parsePhoneNumber","generateNationalNumberDigits","formatNational","replace","getPhoneDigitsForNewCountry","phoneDigits","_ref3","prevCountry","newCountry","useNationalFormat","stripCountryCallingCode","newCountryPrefix","defaultValue","e164","number","asYouType","input","getNumberValue","partial_national_significant_number","getNationalSignificantNumberDigits","concat","trimNumber","nationalSignificantNumberPart","overflowDigitsCount","getMaxNumberLength","slice","selectNumberingPlan","numberingPlan","possibleLengths","getCountryForPartialE164Number","partialE164Number","_ref4","derived_country","getCountryFromPossiblyIncompleteInternationalPhoneNumber","onPhoneDigitsChange","_ref5","prevPhoneDigits","countryRequired","international","limitMaxLength","countryCallingCodeEditable","prefix","_value","convertInternationalPhoneDigitsToNational","formatter","getNumber","getCountry","locales","String","prototype","localeCompare","countryCallingCodePrefix","_i","_Object$keys","Object","keys","country_calling_codes","country_calling_code","nationalNumber","intlPhoneNumberPrefix","i","getInitialPhoneDigits","_ref6"],"sources":["E:\\Hilighter\\chatbot\\node_modules\\react-phone-number-input-plus\\source\\helpers\\phoneInputHelpers.js"],"sourcesContent":["import parsePhoneNumber_, {\n\tgetCountryCallingCode,\n\tAsYouType,\n\tMetadata\n} from 'libphonenumber-js/core'\n\nimport getInternationalPhoneNumberPrefix from './getInternationalPhoneNumberPrefix'\n\n/**\n * Decides which country should be pre-selected\n * when the phone number input component is first mounted.\n * @param  {object?} phoneNumber - An instance of `PhoneNumber` class.\n * @param  {string?} country - Pre-defined country (two-letter code).\n * @param  {string[]?} countries - A list of countries available.\n * @param  {object} metadata - `libphonenumber-js` metadata\n * @return {string?}\n */\nexport function getPreSelectedCountry({\n\tvalue,\n\tphoneNumber,\n\tdefaultCountry,\n\tgetAnyCountry,\n\tcountries,\n\trequired,\n\tmetadata\n}) {\n\tlet country\n\n\t// If can get country from E.164 phone number\n\t// then it overrides the `country` passed (or not passed).\n\tif (phoneNumber && phoneNumber.country) {\n\t\t// `country` will be left `undefined` in case of non-detection.\n\t\tcountry = phoneNumber.country\n\t} else if (defaultCountry) {\n\t\tif (!value || couldNumberBelongToCountry(value, defaultCountry, metadata)) {\n\t\t\tcountry = defaultCountry\n\t\t}\n\t}\n\n\t// Only pre-select a country if it's in the available `countries` list.\n\tif (countries && countries.indexOf(country) < 0) {\n\t\tcountry = undefined\n\t}\n\n\t// If there will be no \"International\" option\n\t// then some `country` must be selected.\n\t// It will still be the wrong country though.\n\t// But still country `<select/>` can't be left in a broken state.\n\tif (!country && required && countries && countries.length > 0) {\n\t\tcountry = getAnyCountry()\n\t\t// noCountryMatchesTheNumber = true\n\t}\n\n\treturn country\n}\n\n/**\n * Generates a sorted list of country `<select/>` options.\n * @param  {string[]} countries - A list of two-letter (\"ISO 3166-1 alpha-2\") country codes.\n * @param  {object} labels - Custom country labels. E.g. `{ RU: 'Россия', US: 'США', ... }`.\n * @param  {boolean} addInternationalOption - Whether should include \"International\" option at the top of the list.\n * @return {object[]} A list of objects having shape `{ value : string, label : string }`.\n */\nexport function getCountrySelectOptions({\n\tcountries,\n\tcountryNames,\n\taddInternationalOption,\n\t// `locales` are only used in country name comparator:\n\t// depending on locale, string sorting order could be different.\n\tcompareStringsLocales,\n\tcompareStrings: _compareStrings\n}) {\n\t// Default country name comparator uses `String.localeCompare()`.\n\tif (!_compareStrings) {\n\t\t_compareStrings = compareStrings\n\t}\n\n\t// Generates a `<Select/>` option for each country.\n\tconst countrySelectOptions = countries.map((country) => ({\n\t\tvalue: country,\n\t\t// All `locale` country names included in this library\n\t\t// include all countries (this is checked at build time).\n\t\t// The only case when a country name might be missing\n\t\t// is when a developer supplies their own `labels` property.\n\t\t// To guard against such cases, a missing country name\n\t\t// is substituted by country code.\n\t\tlabel: countryNames[country] || country\n\t}))\n\n\t// Sort the list of countries alphabetically.\n\tcountrySelectOptions.sort((a, b) => _compareStrings(a.label, b.label, compareStringsLocales))\n\n\t// Add the \"International\" option to the country list (if suitable)\n\tif (addInternationalOption) {\n\t\tcountrySelectOptions.unshift({\n\t\t\tlabel: countryNames.ZZ\n\t\t})\n\t}\n\n\treturn countrySelectOptions\n}\n\n/**\n * Parses a E.164 phone number to an instance of `PhoneNumber` class.\n * @param {string?} value = E.164 phone number.\n * @param  {object} metadata - `libphonenumber-js` metadata\n * @return {object} Object having shape `{ country: string?, countryCallingCode: string, number: string }`. `PhoneNumber`: https://gitlab.com/catamphetamine/libphonenumber-js#phonenumber.\n * @example\n * parsePhoneNumber('+78005553535')\n */\nexport function parsePhoneNumber(value, metadata) {\n\treturn parsePhoneNumber_(value || '', metadata)\n}\n\n/**\n * Generates national number digits for a parsed phone.\n * May prepend national prefix.\n * The phone number must be a complete and valid phone number.\n * @param  {object} phoneNumber - An instance of `PhoneNumber` class.\n * @param  {object} metadata - `libphonenumber-js` metadata\n * @return {string}\n * @example\n * getNationalNumberDigits({ country: 'RU', phone: '8005553535' })\n * // returns '88005553535'\n */\nexport function generateNationalNumberDigits(phoneNumber) {\n\treturn phoneNumber.formatNational().replace(/\\D/g, '')\n}\n\n/**\n * Migrates parsed `<input/>` `value` for the newly selected `country`.\n * @param {string?} phoneDigits - Phone number digits (and `+`) parsed from phone number `<input/>` (it's not the same as the `value` property).\n * @param {string?} prevCountry - Previously selected country.\n * @param {string?} newCountry - Newly selected country. Can't be same as previously selected country.\n * @param {object} metadata - `libphonenumber-js` metadata.\n * @param {boolean} useNationalFormat - whether should attempt to convert from international to national number for the new country.\n * @return {string?}\n */\nexport function getPhoneDigitsForNewCountry(phoneDigits, {\n\tprevCountry,\n\tnewCountry,\n\tmetadata,\n\tuseNationalFormat\n}) {\n\tif (prevCountry === newCountry) {\n\t\treturn phoneDigits\n\t}\n\n\t// If `parsed_input` is empty\n\t// then no need to migrate anything.\n\tif (!phoneDigits) {\n\t\tif (useNationalFormat) {\n\t\t\treturn ''\n\t\t} else {\n\t\t\t// If `phoneDigits` is empty then set `phoneDigits` to\n\t\t\t// `+{getCountryCallingCode(newCountry)}`.\n\t\t\treturn getInternationalPhoneNumberPrefix(newCountry, metadata)\n\t\t}\n\t}\n\n\t// If switching to some country.\n\t// (from \"International\" or another country)\n\t// If switching from \"International\" then `phoneDigits` starts with a `+`.\n\t// Otherwise it may or may not start with a `+`.\n\tif (newCountry) {\n\t\t// If the phone number was entered in international format\n\t\t// then migrate it to the newly selected country.\n\t\t// The phone number may be incomplete.\n\t\t// The phone number entered not necessarily starts with\n\t\t// the previously selected country phone prefix.\n\t\tif (phoneDigits[0] === '+') {\n\t\t\t// If the international phone number is for the new country\n\t\t\t// then convert it to local if required.\n\t\t\tif (useNationalFormat) {\n\t\t\t\t// // If a phone number is being input in international form\n\t\t\t\t// // and the country can already be derived from it,\n\t\t\t\t// // and if it is the new country, then format as a national number.\n\t\t\t\t// const derived_country = getCountryFromPossiblyIncompleteInternationalPhoneNumber(phoneDigits, metadata)\n\t\t\t\t// if (derived_country === newCountry) {\n\t\t\t\t// \treturn stripCountryCallingCode(phoneDigits, derived_country, metadata)\n\t\t\t\t// }\n\n\t\t\t\t// Actually, the two countries don't necessarily need to match:\n\t\t\t\t// the condition could be looser here, because several countries\n\t\t\t\t// might share the same international phone number format\n\t\t\t\t// (for example, \"NANPA\" countries like US, Canada, etc).\n\t\t\t\t// The looser condition would be just \"same nternational phone number format\"\n\t\t\t\t// which would mean \"same country calling code\" in the context of `libphonenumber-js`.\n\t\t\t\tif (phoneDigits.indexOf('+' + getCountryCallingCode(newCountry, metadata)) === 0) {\n\t\t\t\t\treturn stripCountryCallingCode(phoneDigits, newCountry, metadata)\n\t\t\t\t}\n\n\t\t\t\t// Simply discard the previously entered international phone number,\n\t\t\t\t// because otherwise any \"smart\" transformation like getting the\n\t\t\t\t// \"national (significant) number\" part and then prepending the\n\t\t\t\t// newly selected country's \"country calling code\" to it\n\t\t\t\t// would just be confusing for a user without being actually useful.\n\t\t\t\treturn ''\n\n\t\t\t\t// // Simply strip the leading `+` character\n\t\t\t\t// // therefore simply converting all digits into a \"local\" phone number.\n\t\t\t\t// // https://github.com/catamphetamine/react-phone-number-input/issues/287\n\t\t\t\t// return phoneDigits.slice(1)\n\t\t\t}\n\n\t\t\tif (prevCountry) {\n\t\t\t\tconst newCountryPrefix = getInternationalPhoneNumberPrefix(newCountry, metadata)\n\t\t\t\tif (phoneDigits.indexOf(newCountryPrefix) === 0) {\n\t\t\t\t\treturn phoneDigits\n\t\t\t\t} else {\n\t\t\t\t\treturn newCountryPrefix\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst defaultValue = getInternationalPhoneNumberPrefix(newCountry, metadata)\n\t\t\t\t// If `phoneDigits`'s country calling code part is the same\n\t\t\t\t// as for the new `country`, then leave `phoneDigits` as is.\n\t\t\t\tif (phoneDigits.indexOf(defaultValue) === 0) {\n\t\t\t\t\treturn phoneDigits\n\t\t\t\t}\n\t\t\t\t// If `phoneDigits`'s country calling code part is not the same\n\t\t\t\t// as for the new `country`, then set `phoneDigits` to\n\t\t\t\t// `+{getCountryCallingCode(newCountry)}`.\n\t\t\t\treturn defaultValue\n\t\t\t}\n\n\t\t\t// // If the international phone number already contains\n\t\t\t// // any country calling code then trim the country calling code part.\n\t\t\t// // (that could also be the newly selected country phone code prefix as well)\n\t\t\t// // `phoneDigits` doesn't neccessarily belong to `prevCountry`.\n\t\t\t// // (e.g. if a user enters an international number\n\t\t\t// //  not belonging to any of the reduced `countries` list).\n\t\t\t// phoneDigits = stripCountryCallingCode(phoneDigits, prevCountry, metadata)\n\n\t\t\t// // Prepend country calling code prefix\n\t\t\t// // for the newly selected country.\n\t\t\t// return e164(phoneDigits, newCountry, metadata) || `+${getCountryCallingCode(newCountry, metadata)}`\n\t\t}\n\t}\n\t// If switching to \"International\" from a country.\n\telse {\n\t\t// If the phone number was entered in national format.\n\t\tif (phoneDigits[0] !== '+') {\n\t\t\t// Format the national phone number as an international one.\n\t\t\t// The phone number entered not necessarily even starts with\n\t\t\t// the previously selected country phone prefix.\n\t\t\t// Even if the phone number belongs to whole another country\n\t\t\t// it will still be parsed into some national phone number.\n\t\t\t//\n\t\t\t// Ignore the now-uncovered `|| ''` code branch:\n\t\t\t// previously `e164()` function could return an empty string\n\t\t\t// even when `phoneDigits` were not empty.\n\t\t\t// Now it always returns some `value` when there're any `phoneDigits`.\n\t\t\t// Still, didn't remove the `|| ''` code branch just in case\n\t\t\t// that logic changes somehow in some future, so there're no\n\t\t\t// possible bugs related to that.\n\t\t\t//\n\t\t\t// (ignore the `|| ''` code branch)\n\t\t\t/* istanbul ignore next */\n\t\t\treturn e164(phoneDigits, prevCountry, metadata) || ''\n\t\t}\n\t}\n\n\treturn phoneDigits\n}\n\n/**\n * Converts phone number digits to a (possibly incomplete) E.164 phone number.\n * @param  {string?} number - A possibly incomplete phone number digits string. Can be a possibly incomplete E.164 phone number.\n * @param  {string?} country\n * @param  {object} metadata - `libphonenumber-js` metadata.\n * @return {string?}\n */\nexport function e164(number, country, metadata) {\n\tif (!number) {\n\t\treturn\n\t}\n\t// If the phone number is being input in international format.\n\tif (number[0] === '+') {\n\t\t// If it's just the `+` sign then return nothing.\n\t\tif (number === '+') {\n\t\t\treturn\n\t\t}\n\t\t// Return a E.164 phone number.\n\t\t//\n\t\t// Could return `number` \"as is\" here, but there's a possibility\n\t\t// that some user might incorrectly input an international number\n\t\t// with a \"national prefix\". Such numbers aren't considered valid,\n\t\t// but `libphonenumber-js` is \"forgiving\" when it comes to parsing\n\t\t// user's input, and this input component follows that behavior.\n\t\t//\n\t\tconst asYouType = new AsYouType(country, metadata)\n\t\tasYouType.input(number)\n\t\t// This function would return `undefined` only when `number` is `\"+\"`,\n\t\t// but at this point it is known that `number` is not `\"+\"`.\n\t\treturn asYouType.getNumberValue()\n\t}\n\t// For non-international phone numbers\n\t// an accompanying country code is required.\n\t// The situation when `country` is `undefined`\n\t// and a non-international phone number is passed\n\t// to this function shouldn't happen.\n\tif (!country) {\n\t\treturn\n\t}\n\tconst partial_national_significant_number = getNationalSignificantNumberDigits(number, country, metadata)\n\t//\n\t// Even if no \"national (significant) number\" digits have been input,\n\t// still return a non-`undefined` value.\n\t// https://gitlab.com/catamphetamine/react-phone-number-input/-/issues/113\n\t//\n\t// For example, if the user has selected country `US` and entered `\"1\"`\n\t// then that `\"1\"` is just a \"national prefix\" and no \"national (significant) number\"\n\t// digits have been input yet. Still, return `\"+1\"` as `value` in such cases,\n\t// because otherwise the app would think that the input is empty and mark it as such\n\t// while in reality it isn't empty, which might be thought of as a \"bug\", or just\n\t// a \"weird\" behavior.\n\t//\n\t// if (partial_national_significant_number) {\n\t\treturn `+${getCountryCallingCode(country, metadata)}${partial_national_significant_number || ''}`\n\t// }\n}\n\n/**\n * Trims phone number digits if they exceed the maximum possible length\n * for a national (significant) number for the country.\n * @param  {string} number - A possibly incomplete phone number digits string. Can be a possibly incomplete E.164 phone number.\n * @param  {string} country\n * @param  {object} metadata - `libphonenumber-js` metadata.\n * @return {string} Can be empty.\n */\nexport function trimNumber(number, country, metadata) {\n\tconst nationalSignificantNumberPart = getNationalSignificantNumberDigits(number, country, metadata)\n\tif (nationalSignificantNumberPart) {\n\t\tconst overflowDigitsCount = nationalSignificantNumberPart.length - getMaxNumberLength(country, metadata)\n\t\tif (overflowDigitsCount > 0) {\n\t\t\treturn number.slice(0, number.length - overflowDigitsCount)\n\t\t}\n\t}\n\treturn number\n}\n\nfunction getMaxNumberLength(country, metadata) {\n\t// Get \"possible lengths\" for a phone number of the country.\n\tmetadata = new Metadata(metadata)\n\tmetadata.selectNumberingPlan(country)\n\t// Return the last \"possible length\".\n\treturn metadata.numberingPlan.possibleLengths()[metadata.numberingPlan.possibleLengths().length - 1]\n}\n\n// If the phone number being input is an international one\n// then tries to derive the country from the phone number.\n// (regardless of whether there's any country currently selected)\n/**\n * @param {string} partialE164Number - A possibly incomplete E.164 phone number.\n * @param {string?} country - Currently selected country.\n * @param {string[]?} countries - A list of available countries. If not passed then \"all countries\" are assumed.\n * @param  {object} metadata - `libphonenumber-js` metadata.\n * @return {string?}\n */\nexport function getCountryForPartialE164Number(partialE164Number, {\n\tcountry,\n\tcountries,\n\trequired,\n\tmetadata\n}) {\n\tif (partialE164Number === '+') {\n\t\t// Don't change the currently selected country yet.\n\t\treturn country\n\t}\n\n\tconst derived_country = getCountryFromPossiblyIncompleteInternationalPhoneNumber(partialE164Number, metadata)\n\n\t// If a phone number is being input in international form\n\t// and the country can already be derived from it,\n\t// then select that country.\n\tif (derived_country && (!countries || (countries.indexOf(derived_country) >= 0))) {\n\t\treturn derived_country\n\t}\n\t// If \"International\" country option has not been disabled\n\t// and the international phone number entered doesn't correspond\n\t// to the currently selected country then reset the currently selected country.\n\telse if (country &&\n\t\t!required &&\n\t\t!couldNumberBelongToCountry(partialE164Number, country, metadata)) {\n\t\treturn undefined\n\t}\n\n\t// Don't change the currently selected country.\n\treturn country\n}\n\n/**\n * Parses `<input/>` value. Derives `country` from `input`. Derives an E.164 `value`.\n * @param  {string?} phoneDigits — Parsed `<input/>` value. Examples: `\"\"`, `\"+\"`, `\"+123\"`, `\"123\"`.\n * @param  {string?} prevPhoneDigits — Previous parsed `<input/>` value. Examples: `\"\"`, `\"+\"`, `\"+123\"`, `\"123\"`.\n * @param  {string?} country - Currently selected country.\n * @param  {boolean} countryRequired - Is selecting some country required.\n * @param  {function} getAnyCountry - Can be used to get any country when selecting some country required.\n * @param  {string[]?} countries - A list of available countries. If not passed then \"all countries\" are assumed.\n * @param  {boolean} international - Set to `true` to force international phone number format (leading `+`). Set to `false` to force \"national\" phone number format. Is `undefined` by default.\n * @param  {boolean} limitMaxLength — Whether to enable limiting phone number max length.\n * @param  {object} metadata - `libphonenumber-js` metadata.\n * @return {object} An object of shape `{ input, country, value }`.\n */\nexport function onPhoneDigitsChange(phoneDigits, {\n\tprevPhoneDigits,\n\tcountry,\n\tdefaultCountry,\n\tcountryRequired,\n\tgetAnyCountry,\n\tcountries,\n\tinternational,\n\tlimitMaxLength,\n\tcountryCallingCodeEditable,\n\tmetadata\n}) {\n\tif (international && countryCallingCodeEditable === false) {\n\t\tconst prefix = getInternationalPhoneNumberPrefix(country, metadata)\n\t\t// The `<input/>` value must start with the country calling code.\n\t\tif (phoneDigits.indexOf(prefix) !== 0) {\n\t\t\tlet value\n\t\t\t// If a phone number input is declared as\n\t\t\t// `international` and `withCountryCallingCode`,\n\t\t\t// then it's gonna be non-empty even before the user\n\t\t\t// has input anything in it.\n\t\t\t// This will result in its contents (the country calling code part)\n\t\t\t// being selected when the user tabs into such field.\n\t\t\t// If the user then starts inputting the national part digits,\n\t\t\t// then `<input/>` value changes from `+xxx` to `y`\n\t\t\t// because inputting anything while having the `<input/>` value\n\t\t\t// selected results in erasing the `<input/>` value.\n\t\t\t// So, the component handles such case by restoring\n\t\t\t// the intended `<input/>` value: `+xxxy`.\n\t\t\t// https://gitlab.com/catamphetamine/react-phone-number-input/-/issues/43\n\t\t\tif (phoneDigits && phoneDigits[0] !== '+') {\n\t\t\t\tphoneDigits = prefix + phoneDigits\n\t\t\t\tvalue = e164(phoneDigits, country, metadata)\n\t\t\t} else {\n\t\t\t\tphoneDigits = prefix\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tphoneDigits,\n\t\t\t\tvalue,\n\t\t\t\tcountry\n\t\t\t}\n\t\t}\n\t}\n\n\t// If `international` property is `false`, then it means\n\t// \"enforce national-only format during input\",\n\t// so, if that's the case, then remove all `+` characters,\n\t// but only if some country is currently selected.\n\t// (not if \"International\" country is selected).\n\tif (international === false && country && phoneDigits && phoneDigits[0] === '+') {\n\t\tphoneDigits = convertInternationalPhoneDigitsToNational(phoneDigits, country, metadata)\n\t}\n\n\t// Trim the input to not exceed the maximum possible number length.\n\tif (phoneDigits && country && limitMaxLength) {\n\t\tphoneDigits = trimNumber(phoneDigits, country, metadata)\n\t}\n\n\t// If this `onChange()` event was triggered\n\t// as a result of selecting \"International\" country,\n\t// then force-prepend a `+` sign if the phone number\n\t// `<input/>` value isn't in international format.\n\t// Also, force-prepend a `+` sign if international\n\t// phone number input format is set.\n\tif (phoneDigits && phoneDigits[0] !== '+' && (!country || international)) {\n\t\tphoneDigits = '+' + phoneDigits\n\t}\n\n\t// If the previously entered phone number\n\t// has been entered in international format\n\t// and the user decides to erase it,\n\t// then also reset the `country`\n\t// because it was most likely automatically selected\n\t// while the user was typing in the phone number\n\t// in international format.\n\t// This fixes the issue when a user is presented\n\t// with a phone number input with no country selected\n\t// and then types in their local phone number\n\t// then discovers that the input's messed up\n\t// (a `+` has been prepended at the start of their input\n\t//  and a random country has been selected),\n\t// decides to undo it all by erasing everything\n\t// and then types in their local phone number again\n\t// resulting in a seemingly correct phone number\n\t// but in reality that phone number has incorrect country.\n\t// https://github.com/catamphetamine/react-phone-number-input/issues/273\n\tif (!phoneDigits && prevPhoneDigits && prevPhoneDigits[0] === '+') {\n\t\tif (international) {\n\t\t\tcountry = undefined\n\t\t} else {\n\t\t\tcountry = defaultCountry\n\t\t}\n\t}\n\t// Also resets such \"randomly\" selected country\n\t// as soon as the user erases the number\n\t// digit-by-digit up to the leading `+` sign.\n\tif (phoneDigits === '+' && prevPhoneDigits && prevPhoneDigits[0] === '+' && prevPhoneDigits.length > '+'.length) {\n\t\tcountry = undefined\n\t}\n\n\t// Generate the new `value` property.\n\tlet value\n\tif (phoneDigits) {\n\t\tif (phoneDigits[0] === '+') {\n\t\t\tif (phoneDigits === '+') {\n\t\t\t\tvalue = undefined\n\t\t\t} else if (country && getInternationalPhoneNumberPrefix(country, metadata).indexOf(phoneDigits) === 0) {\n\t\t\t\t// Selected a `country` but started inputting an\n\t\t\t\t// international phone number for another country.\n\t\t\t\t// Even though the input value is non-empty,\n\t\t\t\t// the `value` is assumed `undefined` in such case.\n\t\t\t\t// The `country` will be reset (or re-selected)\n\t\t\t\t// immediately after such mismatch has been detected\n\t\t\t\t// by the phone number input component, and `value`\n\t\t\t\t// will be set to the currently entered international prefix.\n\t\t\t\t//\n\t\t\t\t// For example, if selected `country` `\"US\"`\n\t\t\t\t// and started inputting phone number `\"+2\"`\n\t\t\t\t// then `value` `undefined` will be returned from this function,\n\t\t\t\t// and then, immediately after that, `country` will be reset\n\t\t\t\t// and the `value` will be set to `\"+2\"`.\n\t\t\t\t//\n\t\t\t\tvalue = undefined\n\t\t\t} else {\n\t\t\t\tvalue = e164(phoneDigits, country, metadata)\n\t\t\t}\n\t\t} else {\n\t\t\tvalue = e164(phoneDigits, country, metadata)\n\t\t}\n\t}\n\n\t// Derive the country from the phone number.\n\t// (regardless of whether there's any country currently selected,\n\t//  because there could be several countries corresponding to one country calling code)\n\tif (value) {\n\t\tcountry = getCountryForPartialE164Number(value, {\n\t\t\tcountry,\n\t\t\tcountries,\n\t\t\tmetadata\n\t\t})\n\t\t// If `international` property is `false`, then it means\n\t\t// \"enforce national-only format during input\",\n\t\t// so, if that's the case, then remove all `+` characters,\n\t\t// but only if some country is currently selected.\n\t\t// (not if \"International\" country is selected).\n\t\tif (international === false && country && phoneDigits && phoneDigits[0] === '+') {\n\t\t\tphoneDigits = convertInternationalPhoneDigitsToNational(phoneDigits, country, metadata)\n\t\t\t// Re-calculate `value` because `phoneDigits` has changed.\n\t\t\tvalue = e164(phoneDigits, country, metadata)\n\t\t}\n\t}\n\n\tif (!country && countryRequired) {\n\t\tcountry = defaultCountry || getAnyCountry()\n\t}\n\n\treturn {\n\t\tphoneDigits,\n\t\tcountry,\n\t\tvalue\n\t}\n}\n\nfunction convertInternationalPhoneDigitsToNational(input, country, metadata) {\n\t// Handle the case when a user might have pasted\n\t// a phone number in international format.\n\tif (input.indexOf(getInternationalPhoneNumberPrefix(country, metadata)) === 0) {\n\t\t// Create \"as you type\" formatter.\n\t\tconst formatter = new AsYouType(country, metadata)\n\t\t// Input partial national phone number.\n\t\tformatter.input(input)\n\t\t// Return the parsed partial national phone number.\n\t\tconst phoneNumber = formatter.getNumber()\n\t\tif (phoneNumber) {\n\t\t\t// Transform the number to a national one,\n\t\t\t// and remove all non-digits.\n\t\t\treturn phoneNumber.formatNational().replace(/\\D/g, '')\n\t\t} else {\n\t\t\treturn ''\n\t\t}\n\t} else {\n\t\t// Just remove the `+` sign.\n\t\treturn input.replace(/\\D/g, '')\n\t}\n}\n\n/**\n * Determines the country for a given (possibly incomplete) E.164 phone number.\n * @param  {string} number - A possibly incomplete E.164 phone number.\n * @param  {object} metadata - `libphonenumber-js` metadata.\n * @return {string?}\n */\nexport function getCountryFromPossiblyIncompleteInternationalPhoneNumber(number, metadata) {\n\tconst formatter = new AsYouType(null, metadata)\n\tformatter.input(number)\n\t// // `001` is a special \"non-geograpical entity\" code\n\t// // in Google's `libphonenumber` library.\n\t// if (formatter.getCountry() === '001') {\n\t// \treturn\n\t// }\n\treturn formatter.getCountry()\n}\n\n/**\n * Compares two strings.\n * A helper for `Array.sort()`.\n * @param {string} a — First string.\n * @param {string} b — Second string.\n * @param {(string[]|string)} [locales] — The `locales` argument of `String.localeCompare`.\n */\nexport function compareStrings(a, b, locales) {\n  // Use `String.localeCompare` if it's available.\n  // https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare\n  // Which means everyone except IE <= 10 and Safari <= 10.\n  // `localeCompare()` is available in latest Node.js versions.\n  /* istanbul ignore else */\n  if (String.prototype.localeCompare) {\n    return a.localeCompare(b, locales);\n  }\n  /* istanbul ignore next */\n  return a < b ? -1 : (a > b ? 1 : 0);\n}\n\n/**\n * Strips `+${countryCallingCode}` prefix from an E.164 phone number.\n * @param {string} number - (possibly incomplete) E.164 phone number.\n * @param {string?} country - A possible country for this phone number.\n * @param {object} metadata - `libphonenumber-js` metadata.\n * @return {string}\n */\nexport function stripCountryCallingCode(number, country, metadata) {\n\t// Just an optimization, so that it\n\t// doesn't have to iterate through all country calling codes.\n\tif (country) {\n\t\tconst countryCallingCodePrefix = '+' + getCountryCallingCode(country, metadata)\n\n\t\t// If `country` fits the actual `number`.\n\t\tif (number.length < countryCallingCodePrefix.length) {\n\t\t\tif (countryCallingCodePrefix.indexOf(number) === 0) {\n\t\t\t\treturn ''\n\t\t\t}\n\t\t} else {\n\t\t\tif (number.indexOf(countryCallingCodePrefix) === 0) {\n\t\t\t\treturn number.slice(countryCallingCodePrefix.length)\n\t\t\t}\n\t\t}\n\t}\n\n\t// If `country` doesn't fit the actual `number`.\n\t// Try all available country calling codes.\n\tfor (const country_calling_code of Object.keys(metadata.country_calling_codes)) {\n\t\tif (number.indexOf(country_calling_code) === '+'.length) {\n\t\t\treturn number.slice('+'.length + country_calling_code.length)\n\t\t}\n\t}\n\n\treturn ''\n}\n\n/**\n * Parses a partially entered national phone number digits\n * (or a partially entered E.164 international phone number)\n * and returns the national significant number part.\n * National significant number returned doesn't come with a national prefix.\n * @param {string} number - National number digits. Or possibly incomplete E.164 phone number.\n * @param {string?} country\n * @param {object} metadata - `libphonenumber-js` metadata.\n * @return {string} [result]\n */\nexport function getNationalSignificantNumberDigits(number, country, metadata) {\n\t// Create \"as you type\" formatter.\n\tconst formatter = new AsYouType(country, metadata)\n\t// Input partial national phone number.\n\tformatter.input(number)\n\t// Return the parsed partial national phone number.\n\tconst phoneNumber = formatter.getNumber()\n\treturn phoneNumber && phoneNumber.nationalNumber\n}\n\n/**\n * Checks if a partially entered E.164 phone number could belong to a country.\n * @param  {string} number\n * @param  {string} country\n * @return {boolean}\n */\nexport function couldNumberBelongToCountry(number, country, metadata) {\n\tconst intlPhoneNumberPrefix = getInternationalPhoneNumberPrefix(country, metadata)\n\tlet i = 0\n\twhile (i < number.length && i < intlPhoneNumberPrefix.length) {\n\t\tif (number[i] !== intlPhoneNumberPrefix[i]) {\n\t\t\treturn false\n\t\t}\n\t\ti++\n\t}\n\treturn true\n}\n\n/**\n * Gets initial \"phone digits\" (including `+`, if using international format).\n * @return {string} [phoneDigits] Returns `undefined` if there should be no initial \"phone digits\".\n */\nexport function getInitialPhoneDigits({\n\tvalue,\n\tphoneNumber,\n\tdefaultCountry,\n\tinternational,\n\tuseNationalFormat,\n\tmetadata\n}) {\n\t// If the `value` (E.164 phone number)\n\t// belongs to the currently selected country\n\t// and `useNationalFormat` is `true`\n\t// then convert `value` (E.164 phone number)\n\t// to a local phone number digits.\n\t// E.g. '+78005553535' -> '88005553535'.\n\tif ((international === false || useNationalFormat) && phoneNumber && phoneNumber.country) {\n\t\treturn generateNationalNumberDigits(phoneNumber)\n\t}\n\t// If `international` property is `true`,\n\t// meaning \"enforce international phone number format\",\n\t// then always show country calling code in the input field.\n\tif (!value && international && defaultCountry) {\n\t\treturn getInternationalPhoneNumberPrefix(defaultCountry, metadata)\n\t}\n\treturn value\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}