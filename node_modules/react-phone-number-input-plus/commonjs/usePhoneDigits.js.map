{"version":3,"sources":["../source/usePhoneDigits.js"],"names":["usePhoneDigits","value","onChange","country","defaultCountry","international","withCountryCallingCode","useNationalFormatForDefaultCountryValue","metadata","countryMismatchDetected","onCountryMismatch","actualCountry","console","error","current","getInitialPhoneDigits","options","getPhoneDigitsForValue","args","apply","prevCountry","setPrevCountry","prevDefaultCountry","setPrevDefaultCountry","phoneDigits","setPhoneDigits","valueForPhoneDigits","setValueForPhoneDigits","rerenderTrigger","setRerenderTrigger","rerender","getValueForPhoneDigits","asYouType","AsYouType","input","getNumberValue","onSetPhoneDigits","prefix","indexOf","undefined","slice","phoneNumber","getNumber","countryCallingCode","nationalNumber","formatNational"],"mappings":"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","sourcesContent":["import { useRef, useState, useCallback, useEffect } from 'react'\nimport { AsYouType, getCountryCallingCode, parseDigits } from 'libphonenumber-js/core'\n\nimport getInternationalPhoneNumberPrefix from './helpers/getInternationalPhoneNumberPrefix'\n\n/**\n * Returns `[phoneDigits, setPhoneDigits]`.\n * \"Phone digits\" includes not only \"digits\" but also a `+` sign.\n */\nexport default function usePhoneDigits({\n\tvalue,\n\tonChange,\n\tcountry,\n\tdefaultCountry,\n\tinternational,\n\twithCountryCallingCode,\n\tuseNationalFormatForDefaultCountryValue,\n\tmetadata\n}) {\n\tconst countryMismatchDetected = useRef()\n\tconst onCountryMismatch = (value, country, actualCountry) => {\n\t\tconsole.error(`[react-phone-number-input] Expected phone number ${value} to correspond to country ${country} but ${actualCountry ? 'in reality it corresponds to country ' + actualCountry : 'it doesn\\'t'}.`)\n\t\tcountryMismatchDetected.current = true\n\t}\n\n\tconst getInitialPhoneDigits = (options) => {\n\t\treturn getPhoneDigitsForValue(\n\t\t\tvalue,\n\t\t\tcountry,\n\t\t\tinternational,\n\t\t\twithCountryCallingCode,\n\t\t\tdefaultCountry,\n\t\t\tuseNationalFormatForDefaultCountryValue,\n\t\t\tmetadata,\n\t\t\t(...args) => {\n\t\t\t\tif (options && options.onCountryMismatch) {\n\t\t\t\t\toptions.onCountryMismatch()\n\t\t\t\t}\n\t\t\t\tonCountryMismatch.apply(this, args)\n\t\t\t}\n\t\t)\n\t}\n\n\t// This is only used to detect `country` property change.\n\tconst [prevCountry, setPrevCountry] = useState(country)\n\t// This is only used to detect `defaultCountry` property change.\n\tconst [prevDefaultCountry, setPrevDefaultCountry] = useState(defaultCountry)\n\t// `phoneDigits` is the `value` passed to the `<input/>`.\n\tconst [phoneDigits, setPhoneDigits] = useState(getInitialPhoneDigits())\n\t// This is only used to detect `value` property changes.\n\tconst [valueForPhoneDigits, setValueForPhoneDigits] = useState(value)\n\n\t// Rerender hack.\n\tconst [rerenderTrigger, setRerenderTrigger] = useState()\n\tconst rerender = useCallback(() => setRerenderTrigger({}), [setRerenderTrigger])\n\n\tfunction getValueForPhoneDigits(phoneDigits) {\n\t\t// If the user hasn't input any digits then `value` is `undefined`.\n\t\tif (!phoneDigits) {\n\t\t\treturn\n\t\t}\n\t\tif (country && international && !withCountryCallingCode) {\n\t\t\tphoneDigits = `+${getCountryCallingCode(country, metadata)}${phoneDigits}`\n\t\t}\n\t\t// Return the E.164 phone number value.\n\t\t//\n\t\t// Even if no \"national (significant) number\" digits have been input,\n\t\t// still return a non-`undefined` value.\n\t\t// https://gitlab.com/catamphetamine/react-phone-number-input/-/issues/113\n\t\t//\n\t\t// For example, if the user has selected country `US` and entered `\"1\"`\n\t\t// then that `\"1\"` is just a \"national prefix\" and no \"national (significant) number\"\n\t\t// digits have been input yet. Still, return `\"+1\"` as `value` in such cases,\n\t\t// because otherwise the app would think that the input is empty and mark it as such\n\t\t// while in reality it isn't empty, which might be thought of as a \"bug\", or just\n\t\t// a \"weird\" behavior.\n\t\t//\n\t\t// The only case when there's any input and `getNumberValue()` still returns `undefined`\n\t\t// is when that input is `\"+\"`.\n\t\t//\n\t\tconst asYouType = new AsYouType(country || defaultCountry, metadata)\n\t\tasYouType.input(phoneDigits)\n\t\treturn asYouType.getNumberValue()\n\t}\n\n\t// If `value` property has been changed externally\n\t// then re-initialize the component.\n\tuseEffect(() => {\n\t\tif (value !== valueForPhoneDigits) {\n\t\t\tsetValueForPhoneDigits(value)\n\t\t\tsetPhoneDigits(getInitialPhoneDigits())\n\t\t}\n\t}, [value])\n\n\t// If the `country` has been changed then re-initialize the component.\n\tuseEffect(() => {\n\t\tif (country !== prevCountry) {\n\t\t\tsetPrevCountry(country)\n\t\t\tlet countryMismatchDetected\n\t\t\tconst phoneDigits = getInitialPhoneDigits({\n\t\t\t\tonCountryMismatch() {\n\t\t\t\t\tcountryMismatchDetected = true\n\t\t\t\t}\n\t\t\t})\n\t\t\tsetPhoneDigits(phoneDigits)\n\t\t\tif (countryMismatchDetected) {\n\t\t\t\tsetValueForPhoneDigits(getValueForPhoneDigits(phoneDigits))\n\t\t\t}\n\t\t}\n\t}, [country])\n\n\t// If the `defaultCountry` has been changed then re-initialize the component.\n\tuseEffect(() => {\n\t\tif (defaultCountry !== prevDefaultCountry) {\n\t\t\tsetPrevDefaultCountry(defaultCountry)\n\t\t\tsetPhoneDigits(getInitialPhoneDigits())\n\t\t}\n\t}, [defaultCountry])\n\n\t// Update the `value` after `valueForPhoneDigits` has been updated.\n\tuseEffect(() => {\n\t\tif (valueForPhoneDigits !== value) {\n\t\t\tonChange(valueForPhoneDigits)\n\t\t}\n\t}, [valueForPhoneDigits])\n\n\tconst onSetPhoneDigits = useCallback((phoneDigits) => {\n\t\tlet value\n\t\tif (country) {\n\t\t\tif (international && withCountryCallingCode) {\n\t\t\t\t// The `<input/>` value must start with the country calling code.\n\t\t\t\tconst prefix = getInternationalPhoneNumberPrefix(country, metadata)\n\t\t\t\tif (phoneDigits.indexOf(prefix) !== 0) {\n\t\t\t\t\t// If a user tabs into a phone number input field\n\t\t\t\t\t// that is `international` and `withCountryCallingCode`,\n\t\t\t\t\t// and then starts inputting local phone number digits,\n\t\t\t\t\t// the first digit would get \"swallowed\" if the fix below wasn't implemented.\n\t\t\t\t\t// https://gitlab.com/catamphetamine/react-phone-number-input/-/issues/43\n\t\t\t\t\tif (phoneDigits && phoneDigits[0] !== '+') {\n\t\t\t\t\t\tphoneDigits = prefix + phoneDigits\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// // Reset phone digits if they don't start with the correct prefix.\n\t\t\t\t\t\t// // Undo the `<input/>` value change if it doesn't.\n\t\t\t\t\t\tif (countryMismatchDetected.current) {\n\t\t\t\t\t\t\t// In case of a `country`/`value` mismatch,\n\t\t\t\t\t\t\t// if it performed an \"undo\" here, then\n\t\t\t\t\t\t\t// it wouldn't let a user edit their phone number at all,\n\t\t\t\t\t\t\t// so this special case at least allows phone number editing\n\t\t\t\t\t\t\t// when `value` already doesn't match the `country`.\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// If it simply did `phoneDigits = prefix` here,\n\t\t\t\t\t\t\t// then it could have no effect when erasing phone number\n\t\t\t\t\t\t\t// via Backspace, because `phoneDigits` in `state` wouldn't change\n\t\t\t\t\t\t\t// as a result, because it was `prefix` and it became `prefix`,\n\t\t\t\t\t\t\t// so the component wouldn't rerender, and the user would be able\n\t\t\t\t\t\t\t// to erase the country calling code part, and that part is\n\t\t\t\t\t\t\t// assumed to be non-eraseable. That's why the component is\n\t\t\t\t\t\t\t// forcefully rerendered here.\n\t\t\t\t\t\t\tsetPhoneDigits(prefix)\n\t\t\t\t\t\t\tsetValueForPhoneDigits(undefined)\n\t\t\t\t\t\t\t// Force a re-render of the `<input/>` with previous `phoneDigits` value.\n\t\t\t\t\t\t\treturn rerender()\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Entering phone number either in \"national\" format\n\t\t\t\t// when `country` has been specified, or in \"international\" format\n\t\t\t\t// when `country` has been specified but `withCountryCallingCode` hasn't.\n\t\t\t\t// Therefore, `+` is not allowed.\n\t\t\t\tif (phoneDigits && phoneDigits[0] === '+') {\n\t\t\t\t\t// Remove the `+`.\n\t\t\t\t\tphoneDigits = phoneDigits.slice(1)\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (!defaultCountry) {\n\t\t\t// Force a `+` in the beginning of a `value`\n\t\t\t// when no `country` and `defaultCountry` have been specified.\n\t\t\tif (phoneDigits && phoneDigits[0] !== '+') {\n\t\t\t\t// Prepend a `+`.\n\t\t\t\tphoneDigits = '+' + phoneDigits\n\t\t\t}\n\t\t}\n\t\t// Convert `phoneDigits` to `value`.\n\t\tif (phoneDigits) {\n\t\t\tvalue = getValueForPhoneDigits(phoneDigits)\n\t\t}\n\t\tsetPhoneDigits(phoneDigits)\n\t\tsetValueForPhoneDigits(value)\n\t}, [\n\t\tcountry,\n\t\tinternational,\n\t\twithCountryCallingCode,\n\t\tdefaultCountry,\n\t\tmetadata,\n\t\tsetPhoneDigits,\n\t\tsetValueForPhoneDigits,\n\t\trerender,\n\t\tcountryMismatchDetected\n\t])\n\n\treturn [\n\t\tphoneDigits,\n\t\tonSetPhoneDigits\n\t]\n}\n\n/**\n * Returns phone number input field value for a E.164 phone number `value`.\n * @param  {string} [value]\n * @param  {string} [country]\n * @param  {boolean} [international]\n * @param  {boolean} [withCountryCallingCode]\n * @param  {string} [defaultCountry]\n * @param  {boolean} [useNationalFormatForDefaultCountryValue]\n * @param  {object} metadata\n * @return {string}\n */\nfunction getPhoneDigitsForValue(\n\tvalue,\n\tcountry,\n\tinternational,\n\twithCountryCallingCode,\n\tdefaultCountry,\n\tuseNationalFormatForDefaultCountryValue,\n\tmetadata,\n\tonCountryMismatch\n) {\n\tif (country && international && withCountryCallingCode) {\n\t\tconst prefix = getInternationalPhoneNumberPrefix(country, metadata)\n\t\tif (value) {\n\t\t\tif (value.indexOf(prefix) !== 0) {\n\t\t\t\tonCountryMismatch(value, country)\n\t\t\t}\n\t\t\treturn value\n\t\t}\n\t\treturn prefix\n\t}\n\tif (!value) {\n\t\treturn ''\n\t}\n\tif (!country && !defaultCountry) {\n\t\treturn value\n\t}\n\tconst asYouType = new AsYouType(undefined, metadata)\n\tasYouType.input(value)\n\tconst phoneNumber = asYouType.getNumber()\n\tif (phoneNumber) {\n\t\tif (country) {\n\t\t\tif (phoneNumber.country && phoneNumber.country !== country) {\n\t\t\t\tonCountryMismatch(value, country, phoneNumber.country)\n\t\t\t} else if (phoneNumber.countryCallingCode !== getCountryCallingCode(country, metadata)) {\n\t\t\t\tonCountryMismatch(value, country)\n\t\t\t}\n\t\t\tif (international) {\n\t\t\t\treturn phoneNumber.nationalNumber\n\t\t\t}\n\t\t\treturn parseDigits(phoneNumber.formatNational())\n\t\t} else {\n\t\t\t// `phoneNumber.countryCallingCode` is compared here  instead of\n\t\t\t// `phoneNumber.country`, because, for example, a person could have\n\t\t\t// previously input a phone number (in \"national\" format) that isn't\n\t\t\t// 100% valid for the `defaultCountry`, and if `phoneNumber.country`\n\t\t\t// was compared, then it wouldn't match, and such phone number\n\t\t\t// wouldn't be formatted as a \"national\" one, and instead would be\n\t\t\t// formatted as an \"international\" one, confusing the user.\n\t\t\t// Comparing `phoneNumber.countryCallingCode` works around such issues.\n\t\t\t//\n\t\t\t// Example: `defaultCountry=\"US\"` and the `<input/>` is empty.\n\t\t\t// The user inputs: \"222 333 4444\", which gets formatted to \"(222) 333-4444\".\n\t\t\t// The user then clicks \"Save\", the page is refreshed, and the user sees\n\t\t\t// that the `<input/>` value is now \"+1 222 333 4444\" which confuses the user:\n\t\t\t// the user expected the `<input/>` value to be \"(222) 333-4444\", same as it\n\t\t\t// was when they've just typed it in. The cause of the issue is that \"222 333 4444\"\n\t\t\t// is not a valid national number for US, and `phoneNumber.country` is compared\n\t\t\t// instead of `phoneNumber.countryCallingCode`. After the `phoneNumber.country`\n\t\t\t// comparison is replaced with `phoneNumber.countryCallingCode` one, the issue\n\t\t\t// is no longer the case.\n\t\t\t//\n\t\t\tif (phoneNumber.countryCallingCode && phoneNumber.countryCallingCode === getCountryCallingCode(defaultCountry, metadata) && useNationalFormatForDefaultCountryValue) {\n\t\t\t\treturn parseDigits(phoneNumber.formatNational())\n\t\t\t}\n\t\t\treturn value\n\t\t}\n\t} else {\n\t\treturn ''\n\t}\n}"],"file":"usePhoneDigits.js"}